# QNT9-SRS CI/CD Pipeline
# Implements: Infrastructure -> Source -> Build -> Test -> Release -> Cleanup
# Infrastructure is provisioned on-demand via Terraform and destroyed after non-prod runs
# Environments: dev (development/feature branches), staging, prd (main)

name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - development
      - staging
      - 'feature/**'
      - 'release/**'
    paths:
      - 'services/**'
      - 'infrastructure/**'
      - '.github/workflows/cicd-pipeline.yml'
  pull_request:
    branches:
      - main
      - development
      - staging
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment for deployment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prd
      skip_destroy:
        description: 'Skip infrastructure destruction (keep resources)'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.11'
  COVERAGE_THRESHOLD: 80

jobs:
  # ==========================================================================
  # INFRASTRUCTURE STAGE - Provision AKS/ACR via Terraform
  # ==========================================================================
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      auth-service: ${{ steps.filter.outputs.auth-service }}
      search-service: ${{ steps.filter.outputs.search-service }}
      frontend-service: ${{ steps.filter.outputs.frontend-service }}
      user-service: ${{ steps.filter.outputs.user-service }}
      infrastructure: ${{ steps.filter.outputs.infrastructure }}
      any-service: ${{ steps.filter.outputs.any-service }}
      environment: ${{ steps.set-env.outputs.environment }}
      run_id: ${{ steps.set-env.outputs.run_id }}
      is_ephemeral: ${{ steps.set-env.outputs.is_ephemeral }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Filter paths
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            auth-service:
              - 'services/auth-service/**'
            search-service:
              - 'services/search-service/**'
            frontend-service:
              - 'services/frontend-service/**'
            user-service:
              - 'services/user-service/**'
            infrastructure:
              - 'infrastructure/**'
            any-service:
              - 'services/**'

      - name: Set environment and run configuration
        id: set-env
        run: |
          # Determine environment
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENV="prd"
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            ENV="staging"
          else
            ENV="dev"
          fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          
          # Generate unique run ID for ephemeral deployments
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            RUN_ID="pr${{ github.event.pull_request.number }}"
          else
            RUN_ID="run${{ github.run_number }}"
          fi
          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          
          # Production is never ephemeral
          if [[ "$ENV" == "prd" ]]; then
            echo "is_ephemeral=false" >> $GITHUB_OUTPUT
          else
            echo "is_ephemeral=true" >> $GITHUB_OUTPUT
          fi
          
          echo "Environment: $ENV, Run ID: $RUN_ID"

  provision-infrastructure:
    name: Provision Infrastructure
    runs-on: ubuntu-latest
    needs: detect-changes
    outputs:
      acr_login_server: ${{ steps.terraform.outputs.acr_login_server }}
      acr_admin_username: ${{ steps.terraform.outputs.acr_admin_username }}
      acr_admin_password: ${{ steps.terraform.outputs.acr_admin_password }}
      aks_cluster_name: ${{ steps.terraform.outputs.aks_cluster_name }}
      resource_group_name: ${{ steps.terraform.outputs.resource_group_name }}
    env:
      TF_CLOUD_ORGANIZATION: ${{ secrets.TF_CLOUD_ORGANIZATION }}
      TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
          terraform_wrapper: false

      - name: Determine Workspace Name
        id: workspace
        run: |
          ENV="${{ needs.detect-changes.outputs.environment }}"
          RUN_ID="${{ needs.detect-changes.outputs.run_id }}"
          IS_EPHEMERAL="${{ needs.detect-changes.outputs.is_ephemeral }}"
          
          if [[ "$IS_EPHEMERAL" == "true" ]]; then
            WORKSPACE="qnt9-srs-${ENV}-${RUN_ID}"
          else
            WORKSPACE="qnt9-srs-${ENV}"
          fi
          
          echo "workspace=$WORKSPACE" >> $GITHUB_OUTPUT
          echo "Using Terraform workspace: $WORKSPACE"

      - name: Create or Get TFC Workspace
        id: workspace-setup
        run: |
          WORKSPACE="${{ steps.workspace.outputs.workspace }}"
          ORG="${{ secrets.TF_CLOUD_ORGANIZATION }}"
          
          echo "Checking for workspace: $WORKSPACE in organization: $ORG"
          
          WORKSPACE_RESPONSE=$(curl -s \
            --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
            "https://app.terraform.io/api/v2/organizations/${ORG}/workspaces/${WORKSPACE}")
          
          WORKSPACE_ID=$(echo $WORKSPACE_RESPONSE | jq -r '.data.id // empty')
          
          if [ -z "$WORKSPACE_ID" ] || [ "$WORKSPACE_ID" == "null" ]; then
            echo "Creating workspace: $WORKSPACE"
            CREATE_RESPONSE=$(curl -s \
              --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
              --header "Content-Type: application/vnd.api+json" \
              --request POST \
              --data '{
                "data": {
                  "type": "workspaces",
                  "attributes": {
                    "name": "'"$WORKSPACE"'",
                    "execution-mode": "remote",
                    "auto-apply": true,
                    "terraform-version": "1.9.0",
                    "working-directory": ""
                  }
                }
              }' \
              "https://app.terraform.io/api/v2/organizations/${ORG}/workspaces")
            
            WORKSPACE_ID=$(echo $CREATE_RESPONSE | jq -r '.data.id')
            
            if [ -z "$WORKSPACE_ID" ] || [ "$WORKSPACE_ID" == "null" ]; then
              echo "ERROR: Failed to create workspace"
              echo "$CREATE_RESPONSE" | jq .
              exit 1
            fi
            
            echo "Workspace created with ID: $WORKSPACE_ID"
            
            # Set Azure credentials as workspace environment variables
            for VAR_NAME in ARM_CLIENT_ID ARM_CLIENT_SECRET ARM_SUBSCRIPTION_ID ARM_TENANT_ID; do
              VAR_VALUE="${!VAR_NAME}"
              IS_SENSITIVE=$([[ "$VAR_NAME" == "ARM_CLIENT_SECRET" ]] && echo "true" || echo "false")
              
              curl -s \
                --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
                --header "Content-Type: application/vnd.api+json" \
                --request POST \
                --data '{
                  "data": {
                    "type": "vars",
                    "attributes": {
                      "key": "'"$VAR_NAME"'",
                      "value": "'"$VAR_VALUE"'",
                      "category": "env",
                      "sensitive": '"$IS_SENSITIVE"'
                    }
                  }
                }' \
                "https://app.terraform.io/api/v2/workspaces/$WORKSPACE_ID/vars" > /dev/null
              echo "Set environment variable: $VAR_NAME"
            done
          else
            echo "Workspace already exists with ID: $WORKSPACE_ID"
          fi
          
          echo "workspace_id=$WORKSPACE_ID" >> $GITHUB_OUTPUT

      - name: Set Terraform Variables in Workspace
        run: |
          WORKSPACE_ID="${{ steps.workspace-setup.outputs.workspace_id }}"
          
          # Define Terraform variables
          declare -A TF_VARS=(
            ["environment"]="${{ needs.detect-changes.outputs.environment }}"
            ["ephemeral"]="${{ needs.detect-changes.outputs.is_ephemeral }}"
            ["run_id"]="${{ needs.detect-changes.outputs.run_id }}"
            ["location"]="germanywestcentral"
            ["cost_center"]="QNT9-CICD"
            ["owner_email"]="cicd@qnt9.io"
            ["business_owner_email"]="devops@qnt9.io"
            ["budget_code"]="CICD-${{ needs.detect-changes.outputs.environment }}"
            ["data_classification"]="Internal"
            ["compliance_requirements"]="GDPR"
            ["data_residency"]="Germany"
            ["aks_kubernetes_version"]="1.31.11"
          )
          
          # Set conditional variables based on environment
          if [[ "${{ needs.detect-changes.outputs.is_ephemeral }}" == "true" ]]; then
            TF_VARS["enable_icinga"]="false"
            TF_VARS["enable_function_app"]="false"
            TF_VARS["criticality"]="Low"
          else
            TF_VARS["enable_icinga"]="true"
            TF_VARS["enable_function_app"]="true"
            TF_VARS["criticality"]="${{ needs.detect-changes.outputs.environment == 'prd' && 'Critical' || 'Low' }}"
          fi
          
          if [[ "${{ needs.detect-changes.outputs.environment }}" == "prd" ]]; then
            TF_VARS["aks_node_count"]="3"
            TF_VARS["aks_vm_size"]="Standard_D2s_v3"
          else
            TF_VARS["aks_node_count"]="2"
            TF_VARS["aks_vm_size"]="Standard_B2s"
          fi
          
          TF_VARS["aks_ephemeral_node_count"]="1"
          TF_VARS["aks_ephemeral_vm_size"]="Standard_B2s"
          
          # Create or update each variable
          for VAR_NAME in "${!TF_VARS[@]}"; do
            VAR_VALUE="${TF_VARS[$VAR_NAME]}"
            
            # Determine if value is HCL (boolean/number) or string
            if [[ "$VAR_VALUE" == "true" || "$VAR_VALUE" == "false" || "$VAR_VALUE" =~ ^[0-9]+$ ]]; then
              HCL="true"
            else
              HCL="false"
            fi
            
            curl -s \
              --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
              --header "Content-Type: application/vnd.api+json" \
              --request POST \
              --data '{
                "data": {
                  "type": "vars",
                  "attributes": {
                    "key": "'"$VAR_NAME"'",
                    "value": "'"$VAR_VALUE"'",
                    "category": "terraform",
                    "hcl": '"$HCL"'
                  }
                }
              }' \
              "https://app.terraform.io/api/v2/workspaces/$WORKSPACE_ID/vars" > /dev/null 2>&1 || true
            echo "Set Terraform variable: $VAR_NAME = $VAR_VALUE"
          done

      - name: Upload Configuration to TFC
        id: upload
        uses: hashicorp/tfc-workflows-github/actions/upload-configuration@v1.3.1
        with:
          workspace: ${{ steps.workspace.outputs.workspace }}
          directory: ./infrastructure/terraform
          organization: ${{ secrets.TF_CLOUD_ORGANIZATION }}
          token: ${{ secrets.TF_API_TOKEN }}

      - name: Create Terraform Run
        id: run
        uses: hashicorp/tfc-workflows-github/actions/create-run@v1.3.1
        with:
          workspace: ${{ steps.workspace.outputs.workspace }}
          configuration_version: ${{ steps.upload.outputs.configuration_version_id }}
          message: "CI/CD - ${{ github.event_name }} - ${{ github.sha }}"
          organization: ${{ secrets.TF_CLOUD_ORGANIZATION }}
          token: ${{ secrets.TF_API_TOKEN }}

      - name: Apply Terraform Run
        if: fromJSON(steps.run.outputs.payload).data.attributes.actions.IsConfirmable
        uses: hashicorp/tfc-workflows-github/actions/apply-run@v1.3.1
        with:
          run: ${{ steps.run.outputs.run_id }}
          comment: "Auto-apply from CI/CD - Run ${{ github.run_id }}"
          token: ${{ secrets.TF_API_TOKEN }}

      - name: Wait for Apply Completion
        run: |
          RUN_ID="${{ steps.run.outputs.run_id }}"
          for i in {1..90}; do
            STATUS=$(curl -s \
              --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
              "https://app.terraform.io/api/v2/runs/$RUN_ID" \
              | jq -r '.data.attributes.status')
            
            echo "Run status: $STATUS (attempt $i/90)"
            
            case $STATUS in
              "applied"|"planned_and_finished")
                echo "Terraform apply completed successfully"
                exit 0
                ;;
              "errored"|"canceled"|"force_canceled"|"discarded")
                echo "Terraform run failed with status: $STATUS"
                exit 1
                ;;
              *)
                sleep 20
                ;;
            esac
          done
          echo "Timeout waiting for Terraform apply"
          exit 1

      - name: Get Terraform Outputs
        id: terraform
        run: |
          WORKSPACE="${{ steps.workspace.outputs.workspace }}"
          ORG="${{ secrets.TF_CLOUD_ORGANIZATION }}"
          
          WORKSPACE_ID=$(curl -s \
            --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
            "https://app.terraform.io/api/v2/organizations/${ORG}/workspaces/${WORKSPACE}" \
            | jq -r '.data.id')
          
          STATE_VERSION_RESPONSE=$(curl -s \
            --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
            "https://app.terraform.io/api/v2/workspaces/$WORKSPACE_ID/current-state-version")
          
          STATE_VERSION=$(echo $STATE_VERSION_RESPONSE | jq -r '.data.id')
          
          if [ -z "$STATE_VERSION" ] || [ "$STATE_VERSION" == "null" ]; then
            echo "No state version found"
            exit 1
          fi
          
          OUTPUTS=$(curl -s \
            --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
            "https://app.terraform.io/api/v2/state-versions/$STATE_VERSION/outputs")
          
          ACR_LOGIN_SERVER=$(echo $OUTPUTS | jq -r '.data[] | select(.attributes.name=="acr_login_server") | .attributes.value')
          ACR_ADMIN_USERNAME=$(echo $OUTPUTS | jq -r '.data[] | select(.attributes.name=="acr_admin_username") | .attributes.value')
          ACR_ADMIN_PASSWORD=$(echo $OUTPUTS | jq -r '.data[] | select(.attributes.name=="acr_admin_password") | .attributes.value')
          AKS_CLUSTER_NAME=$(echo $OUTPUTS | jq -r '.data[] | select(.attributes.name=="aks_cluster_name") | .attributes.value')
          RESOURCE_GROUP=$(echo $OUTPUTS | jq -r '.data[] | select(.attributes.name=="resource_group_name") | .attributes.value')
          
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "acr_admin_username=$ACR_ADMIN_USERNAME" >> $GITHUB_OUTPUT
          echo "::add-mask::$ACR_ADMIN_PASSWORD"
          echo "acr_admin_password=$ACR_ADMIN_PASSWORD" >> $GITHUB_OUTPUT
          echo "aks_cluster_name=$AKS_CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "resource_group_name=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          
          echo "ACR: $ACR_LOGIN_SERVER | AKS: $AKS_CLUSTER_NAME"

  # ==========================================================================
  # SOURCE STAGE
  # ==========================================================================
  lint:
    name: Lint and Security Scan
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.any-service == 'true'
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - run: pip install black isort ruff bandit
      - run: black --check --diff services/ || true
      - run: isort --check-only --diff services/ || true
      - run: ruff check services/ || true
      - run: bandit -r services/ -ll -ii --exclude '**/tests/**' || true

  # ==========================================================================
  # BUILD STAGE
  # ==========================================================================
  build-auth-service:
    name: Build Auth Service
    runs-on: ubuntu-latest
    needs: [detect-changes, provision-infrastructure, lint]
    if: |
      always() &&
      (needs.detect-changes.outputs.auth-service == 'true' || github.ref == 'refs/heads/main') &&
      needs.provision-infrastructure.result == 'success' &&
      (needs.lint.result == 'success' || needs.lint.result == 'skipped')
    env:
      REGISTRY: ${{ needs.provision-infrastructure.outputs.acr_login_server }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip
          cache-dependency-path: services/auth-service/requirements.txt
      - name: Install and test
        working-directory: services/auth-service
        run: |
          pip install -r requirements.txt pytest pytest-cov pytest-asyncio
          pytest tests/ -v --cov=app --cov-report=xml --cov-fail-under=${{ env.COVERAGE_THRESHOLD }}
        env:
          JWT_SECRET_KEY: test-secret-key-for-testing-only-32chars
          JWT_ALGORITHM: HS256
          DATABASE_URL: postgresql://test:test@localhost:5432/test
          PASSWORD_HASH_ROUNDS: 4
      - uses: codecov/codecov-action@v4
        with:
          files: services/auth-service/coverage.xml
          flags: auth-service
          token: ${{ secrets.CODECOV_TOKEN }}
        continue-on-error: true
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ needs.provision-infrastructure.outputs.acr_admin_username }}
          password: ${{ needs.provision-infrastructure.outputs.acr_admin_password }}
      - id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/qnt9-auth-service
          tags: |
            type=raw,value=${{ needs.detect-changes.outputs.environment }}-${{ github.sha }}
            type=raw,value=${{ needs.detect-changes.outputs.environment }}-latest
      - uses: docker/build-push-action@v5
        with:
          context: services/auth-service
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  build-search-service:
    name: Build Search Service
    runs-on: ubuntu-latest
    needs: [detect-changes, provision-infrastructure, lint]
    if: |
      always() &&
      (needs.detect-changes.outputs.search-service == 'true' || github.ref == 'refs/heads/main') &&
      needs.provision-infrastructure.result == 'success' &&
      (needs.lint.result == 'success' || needs.lint.result == 'skipped')
    env:
      REGISTRY: ${{ needs.provision-infrastructure.outputs.acr_login_server }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip
          cache-dependency-path: services/search-service/requirements.txt
      - name: Install and test
        working-directory: services/search-service
        run: |
          pip install -r requirements.txt pytest pytest-cov pytest-asyncio
          pytest tests/ -v --cov=app --cov-report=xml --cov-fail-under=70
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test
          JWT_SECRET_KEY: test-secret-key
      - uses: codecov/codecov-action@v4
        with:
          files: services/search-service/coverage.xml
          flags: search-service
          token: ${{ secrets.CODECOV_TOKEN }}
        continue-on-error: true
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ needs.provision-infrastructure.outputs.acr_admin_username }}
          password: ${{ needs.provision-infrastructure.outputs.acr_admin_password }}
      - id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/qnt9-search-service
          tags: |
            type=raw,value=${{ needs.detect-changes.outputs.environment }}-${{ github.sha }}
            type=raw,value=${{ needs.detect-changes.outputs.environment }}-latest
      - uses: docker/build-push-action@v5
        with:
          context: services/search-service
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  build-frontend-service:
    name: Build Frontend Service
    runs-on: ubuntu-latest
    needs: [detect-changes, provision-infrastructure, lint]
    if: |
      always() &&
      (needs.detect-changes.outputs.frontend-service == 'true' || github.ref == 'refs/heads/main') &&
      needs.provision-infrastructure.result == 'success' &&
      (needs.lint.result == 'success' || needs.lint.result == 'skipped')
    env:
      REGISTRY: ${{ needs.provision-infrastructure.outputs.acr_login_server }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip
          cache-dependency-path: services/frontend-service/requirements.txt
      - name: Install and test
        working-directory: services/frontend-service
        run: |
          pip install -r requirements.txt pytest pytest-cov pytest-asyncio
          pytest tests/ -v --cov=app --cov-report=xml --cov-fail-under=70 || true
      - uses: codecov/codecov-action@v4
        with:
          files: services/frontend-service/coverage.xml
          flags: frontend-service
          token: ${{ secrets.CODECOV_TOKEN }}
        continue-on-error: true
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ needs.provision-infrastructure.outputs.acr_admin_username }}
          password: ${{ needs.provision-infrastructure.outputs.acr_admin_password }}
      - id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/qnt9-frontend-service
          tags: |
            type=raw,value=${{ needs.detect-changes.outputs.environment }}-${{ github.sha }}
            type=raw,value=${{ needs.detect-changes.outputs.environment }}-latest
      - uses: docker/build-push-action@v5
        with:
          context: services/frontend-service
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  build-user-service:
    name: Build User Service
    runs-on: ubuntu-latest
    needs: [detect-changes, provision-infrastructure, lint]
    if: |
      always() &&
      (needs.detect-changes.outputs.user-service == 'true' || github.ref == 'refs/heads/main') &&
      needs.provision-infrastructure.result == 'success' &&
      (needs.lint.result == 'success' || needs.lint.result == 'skipped')
    env:
      REGISTRY: ${{ needs.provision-infrastructure.outputs.acr_login_server }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ needs.provision-infrastructure.outputs.acr_admin_username }}
          password: ${{ needs.provision-infrastructure.outputs.acr_admin_password }}
      - id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/qnt9-user-service
          tags: |
            type=raw,value=${{ needs.detect-changes.outputs.environment }}-${{ github.sha }}
            type=raw,value=${{ needs.detect-changes.outputs.environment }}-latest
      - uses: docker/build-push-action@v5
        with:
          context: services/user-service
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ==========================================================================
  # TEST STAGE
  # ==========================================================================
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [detect-changes, provision-infrastructure, build-auth-service, build-search-service, build-frontend-service]
    if: |
      always() &&
      needs.detect-changes.outputs.any-service == 'true' &&
      needs.provision-infrastructure.result == 'success'
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: qnt9
          POSTGRES_PASSWORD: qnt9password
          POSTGRES_DB: qnt9_db
        ports:
          - 5432:5432
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: --health-cmd "redis-cli ping" --health-interval 10s --health-timeout 5s --health-retries 5
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - run: sudo apt-get update && sudo apt-get install -y postgresql-client
      - run: PGPASSWORD=qnt9password psql -h localhost -U qnt9 -d qnt9_db -f infrastructure/postgres/init.sql
      - name: Run tests
        working-directory: tests/integration
        run: |
          pip install -r requirements.txt
          pytest -v --tb=short || true
        env:
          DATABASE_URL: postgresql://qnt9:qnt9password@localhost:5432/qnt9_db
          REDIS_URL: redis://localhost:6379/0
          JWT_SECRET_KEY: test-secret-key

  # ==========================================================================
  # RELEASE STAGE
  # ==========================================================================
  deploy:
    name: Deploy to ${{ needs.detect-changes.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [detect-changes, provision-infrastructure, integration-tests]
    if: |
      always() &&
      needs.provision-infrastructure.result == 'success' &&
      needs.integration-tests.result == 'success'
    environment:
      name: ${{ needs.detect-changes.outputs.environment }}
    env:
      REGISTRY: ${{ needs.provision-infrastructure.outputs.acr_login_server }}
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          creds: '{"clientId":"${{ secrets.ARM_CLIENT_ID }}","clientSecret":"${{ secrets.ARM_CLIENT_SECRET }}","subscriptionId":"${{ secrets.ARM_SUBSCRIPTION_ID }}","tenantId":"${{ secrets.ARM_TENANT_ID }}"}'
      - uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ needs.provision-infrastructure.outputs.resource_group_name }}
          cluster-name: ${{ needs.provision-infrastructure.outputs.aks_cluster_name }}
      - name: Create namespace and secrets
        run: |
          kubectl create namespace qnt9 --dry-run=client -o yaml | kubectl apply -f -
          
          # Create Kubernetes secrets from GitHub secrets
          kubectl create secret generic qnt9-secrets -n qnt9 \
            --from-literal=database-url="${{ secrets.DATABASE_URL }}" \
            --from-literal=jwt-secret-key="${{ secrets.JWT_SECRET_KEY }}" \
            --from-literal=redis-url="${{ secrets.REDIS_URL }}" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Create ACR pull secret
          kubectl create secret docker-registry acr-secret -n qnt9 \
            --docker-server="${{ env.REGISTRY }}" \
            --docker-username="${{ needs.provision-infrastructure.outputs.acr_admin_username }}" \
            --docker-password="${{ needs.provision-infrastructure.outputs.acr_admin_password }}" \
            --dry-run=client -o yaml | kubectl apply -f -
      - name: Deploy services
        run: |
          export IMAGE_TAG="${{ needs.detect-changes.outputs.environment }}-${{ github.sha }}"
          export ENVIRONMENT="${{ needs.detect-changes.outputs.environment }}"
          export ACR_LOGIN_SERVER="${{ env.REGISTRY }}"
          
          # Apply base resources in order
          kubectl apply -f infrastructure/kubernetes/base/namespace.yaml || true
          kubectl apply -f infrastructure/kubernetes/base/service-account.yaml || true
          kubectl apply -f infrastructure/kubernetes/base/network-policy.yaml || true
          kubectl apply -f infrastructure/kubernetes/base/ingress.yaml || true
          
          # Deploy each service
          for service in auth-service search-service frontend-service user-service; do
            if [ -d "infrastructure/kubernetes/$service" ]; then
              for manifest in infrastructure/kubernetes/$service/*.yaml; do
                envsubst < "$manifest" | kubectl apply -f - || true
              done
            fi
          done
      - name: Wait for rollouts
        run: |
          for svc in auth-service search-service frontend-service user-service; do
            kubectl rollout status deployment/$svc -n qnt9 --timeout=300s || true
          done
      - run: kubectl get pods -n qnt9 && kubectl get svc -n qnt9

  # ==========================================================================
  # CLEANUP STAGE - Destroy ephemeral infrastructure (non-prod only)
  # ==========================================================================
  destroy-infrastructure:
    name: Destroy Ephemeral Infrastructure
    runs-on: ubuntu-latest
    needs: [detect-changes, provision-infrastructure, deploy]
    if: |
      always() &&
      needs.detect-changes.outputs.is_ephemeral == 'true' &&
      needs.provision-infrastructure.result == 'success' &&
      github.event.inputs.skip_destroy != 'true'
    env:
      TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
    steps:
      - name: Destroy Infrastructure via TFC
        run: |
          ENV="${{ needs.detect-changes.outputs.environment }}"
          RUN_ID="${{ needs.detect-changes.outputs.run_id }}"
          WORKSPACE="qnt9-srs-${ENV}-${RUN_ID}"
          ORG="${{ secrets.TF_CLOUD_ORGANIZATION }}"
          
          echo "Looking up workspace: $WORKSPACE"
          
          WORKSPACE_RESPONSE=$(curl -s \
            --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
            "https://app.terraform.io/api/v2/organizations/${ORG}/workspaces/${WORKSPACE}")
          
          WORKSPACE_ID=$(echo $WORKSPACE_RESPONSE | jq -r '.data.id // empty')
          
          if [ -z "$WORKSPACE_ID" ] || [ "$WORKSPACE_ID" == "null" ]; then
            echo "Workspace not found, nothing to destroy"
            exit 0
          fi
          
          echo "Creating destroy run for workspace: $WORKSPACE_ID"
          
          # Create a destroy run
          DESTROY_RUN=$(curl -s \
            --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
            --header "Content-Type: application/vnd.api+json" \
            --request POST \
            --data '{
              "data": {
                "type": "runs",
                "attributes": {
                  "is-destroy": true,
                  "message": "Cleanup ephemeral infrastructure - Run ${{ github.run_id }}",
                  "auto-apply": true
                },
                "relationships": {
                  "workspace": {
                    "data": {
                      "type": "workspaces",
                      "id": "'"$WORKSPACE_ID"'"
                    }
                  }
                }
              }
            }' \
            "https://app.terraform.io/api/v2/runs")
          
          DESTROY_RUN_ID=$(echo $DESTROY_RUN | jq -r '.data.id')
          
          if [ -z "$DESTROY_RUN_ID" ] || [ "$DESTROY_RUN_ID" == "null" ]; then
            echo "Failed to create destroy run"
            echo "$DESTROY_RUN" | jq .
            exit 1
          fi
          
          echo "Destroy run created: $DESTROY_RUN_ID"
          
          # Wait for destroy to complete
          for i in {1..60}; do
            STATUS=$(curl -s \
              --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
              "https://app.terraform.io/api/v2/runs/$DESTROY_RUN_ID" \
              | jq -r '.data.attributes.status')
            
            echo "Destroy status: $STATUS (attempt $i/60)"
            
            case $STATUS in
              "applied"|"planned_and_finished")
                echo "Infrastructure destroyed successfully"
                break
                ;;
              "errored"|"canceled"|"force_canceled"|"discarded")
                echo "Destroy run failed with status: $STATUS"
                exit 1
                ;;
              *)
                sleep 30
                ;;
            esac
          done

      - name: Delete TFC Workspace
        if: always()
        run: |
          ENV="${{ needs.detect-changes.outputs.environment }}"
          RUN_ID="${{ needs.detect-changes.outputs.run_id }}"
          WORKSPACE="qnt9-srs-${ENV}-${RUN_ID}"
          ORG="${{ secrets.TF_CLOUD_ORGANIZATION }}"
          
          WORKSPACE_ID=$(curl -s \
            --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
            "https://app.terraform.io/api/v2/organizations/${ORG}/workspaces/${WORKSPACE}" \
            | jq -r '.data.id')
          
          if [ "$WORKSPACE_ID" != "null" ] && [ -n "$WORKSPACE_ID" ]; then
            curl -s \
              --header "Authorization: Bearer ${{ secrets.TF_API_TOKEN }}" \
              --request DELETE \
              "https://app.terraform.io/api/v2/workspaces/$WORKSPACE_ID?force=true"
            echo "Workspace $WORKSPACE deleted"
          else
            echo "Workspace not found, skipping delete"
          fi

  # ==========================================================================
  # SUMMARY
  # ==========================================================================
  summary:
    name: Pipeline Summary
    runs-on: ubuntu-latest
    needs: [detect-changes, provision-infrastructure, lint, build-auth-service, build-search-service, build-frontend-service, integration-tests, deploy, destroy-infrastructure]
    if: always()
    steps:
      - name: Summary
        run: |
          echo "## QNT9-SRS CI/CD Pipeline" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ needs.detect-changes.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Ephemeral | ${{ needs.detect-changes.outputs.is_ephemeral }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Run ID | ${{ needs.detect-changes.outputs.run_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Result |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Infrastructure | ${{ needs.provision-infrastructure.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Lint | ${{ needs.lint.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Auth Service | ${{ needs.build-auth-service.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Search Service | ${{ needs.build-search-service.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend Service | ${{ needs.build-frontend-service.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Integration | ${{ needs.integration-tests.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy | ${{ needs.deploy.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Cleanup | ${{ needs.destroy-infrastructure.result }} |" >> $GITHUB_STEP_SUMMARY
