# QNT9-SRS CI/CD Pipeline
# Infrastructure-on-demand pattern with HCP Terraform Cloud and Azure AKS/ACR
# 
# This pipeline implements:
# - Multi-environment deployment (dev, staging, prd)
# - Ephemeral infrastructure for non-production
# - Docker image building and pushing to ACR
# - Kubernetes deployment to AKS
# - Automated cleanup for ephemeral environments

name: QNT9-SRS CI/CD Pipeline

on:
  push:
    branches:
      - main
      - development
      - staging
      - 'feature/**'
      - 'release/**'
  pull_request:
    branches:
      - main
      - development
      - staging
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prd
      skip_destroy:
        description: 'Skip infrastructure cleanup (for debugging)'
        required: false
        default: false
        type: boolean
      force_deploy:
        description: 'Force deployment even without code changes'
        required: false
        default: false
        type: boolean

# Ensure only one pipeline runs per branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  TF_CLOUD_ORGANIZATION: "tim-krebs-org"
  TF_VAR_FILE_PATH: "infrastructure/terraform"
  SERVICES: "auth-service,search-service,frontend-service"

jobs:
  # ============================================================================
  # STAGE 1: DETECT CHANGES AND DETERMINE ENVIRONMENT
  # ============================================================================
  detect-changes:
    name: ðŸ” Detect Changes
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      ephemeral: ${{ steps.env.outputs.ephemeral }}
      run_id: ${{ steps.env.outputs.run_id }}
      workspace_name: ${{ steps.env.outputs.workspace_name }}
      services_changed: ${{ steps.changes.outputs.services }}
      infra_changed: ${{ steps.changes.outputs.infra }}
      any_changed: ${{ steps.changes.outputs.any }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect file changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            services:
              - 'services/**'
            infra:
              - 'infrastructure/terraform/**'
              - 'infrastructure/kubernetes/**'
            any:
              - '**'

      - name: Determine environment
        id: env
        run: |
          # Default values
          ENVIRONMENT="dev"
          EPHEMERAL="true"
          
          # Determine environment based on branch or input
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            if [[ "$ENVIRONMENT" == "prd" ]]; then
              EPHEMERAL="false"
            fi
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="prd"
            EPHEMERAL="false"
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            ENVIRONMENT="staging"
            EPHEMERAL="true"
          elif [[ "${{ github.ref }}" == "refs/heads/development" ]]; then
            ENVIRONMENT="dev"
            EPHEMERAL="true"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            ENVIRONMENT="dev"
            EPHEMERAL="true"
          fi
          
          # Generate run ID for ephemeral workspaces
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            RUN_ID="pr${{ github.event.pull_request.number }}"
          else
            RUN_ID="run${{ github.run_number }}"
          fi
          
          # Workspace naming
          if [[ "$EPHEMERAL" == "true" ]]; then
            WORKSPACE_NAME="qnt9-srs-${ENVIRONMENT}-${RUN_ID}"
          else
            WORKSPACE_NAME="qnt9-srs-${ENVIRONMENT}"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "ephemeral=$EPHEMERAL" >> $GITHUB_OUTPUT
          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          echo "workspace_name=$WORKSPACE_NAME" >> $GITHUB_OUTPUT
          
          echo "ðŸ“‹ Environment Configuration:"
          echo "  Environment: $ENVIRONMENT"
          echo "  Ephemeral: $EPHEMERAL"
          echo "  Run ID: $RUN_ID"
          echo "  Workspace: $WORKSPACE_NAME"

  # ============================================================================
  # STAGE 2: CODE QUALITY (SOURCE STAGE)
  # ============================================================================
  lint:
    name: ðŸ§¹ Lint & Format
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.services_changed == 'true' || github.event.inputs.force_deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install linting tools
        run: |
          pip install black isort ruff bandit

      - name: Run Black (formatting)
        run: |
          black --check --diff services/

      - name: Run isort (imports)
        run: |
          isort --check-only --diff services/

      - name: Run Ruff (linting)
        run: |
          ruff check services/

      - name: Run Bandit (security)
        run: |
          bandit -r services/ -x '**/tests/**' --severity-level medium
        continue-on-error: true

  # ============================================================================
  # STAGE 3: INFRASTRUCTURE PROVISIONING
  # ============================================================================
  terraform-provision:
    name: ðŸ—ï¸ Provision Infrastructure
    runs-on: ubuntu-latest
    needs: [detect-changes, lint]
    if: |
      always() && 
      (needs.lint.result == 'success' || needs.lint.result == 'skipped') &&
      needs.detect-changes.result == 'success'
    outputs:
      acr_login_server: ${{ steps.outputs.outputs.acr_login_server }}
      acr_admin_user: ${{ steps.outputs.outputs.acr_admin_user }}
      aks_cluster_name: ${{ steps.outputs.outputs.aks_cluster_name }}
      resource_group: ${{ steps.outputs.outputs.resource_group }}
    
    env:
      TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
      TF_WORKSPACE: ${{ needs.detect-changes.outputs.workspace_name }}
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Check/Create HCP Terraform Workspace
        id: workspace
        run: |
          set -e
          
          WORKSPACE_NAME="${{ needs.detect-changes.outputs.workspace_name }}"
          ENVIRONMENT="${{ needs.detect-changes.outputs.environment }}"
          EPHEMERAL="${{ needs.detect-changes.outputs.ephemeral }}"
          
          echo "ðŸ” Checking workspace: $WORKSPACE_NAME"
          
          # Check if workspace exists
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            --header "Authorization: Bearer $TF_API_TOKEN" \
            --header "Content-Type: application/vnd.api+json" \
            "https://app.terraform.io/api/v2/organizations/$TF_CLOUD_ORGANIZATION/workspaces/$WORKSPACE_NAME")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n-1)
          
          if [[ "$HTTP_CODE" == "200" ]]; then
            echo "âœ… Workspace exists"
            WORKSPACE_ID=$(echo "$BODY" | jq -r '.data.id')
          else
            echo "ðŸ“ Creating workspace..."
            
            # Create workspace with tags for tag-based selection
            CREATE_RESPONSE=$(curl -s \
              --header "Authorization: Bearer $TF_API_TOKEN" \
              --header "Content-Type: application/vnd.api+json" \
              --request POST \
              --data '{
                "data": {
                  "attributes": {
                    "name": "'"$WORKSPACE_NAME"'",
                    "terraform_version": "1.6.0",
                    "working-directory": "infrastructure/terraform",
                    "auto-apply": true,
                    "execution-mode": "local",
                    "description": "QNT9-SRS '"$ENVIRONMENT"' environment (ephemeral: '"$EPHEMERAL"')",
                    "tag-names": ["qnt9-srs", "'"$ENVIRONMENT"'", "'"$(if [[ "$EPHEMERAL" == "true" ]]; then echo "ephemeral"; else echo "persistent"; fi)"'"]
                  },
                  "type": "workspaces"
                }
              }' \
              "https://app.terraform.io/api/v2/organizations/$TF_CLOUD_ORGANIZATION/workspaces")
            
            WORKSPACE_ID=$(echo "$CREATE_RESPONSE" | jq -r '.data.id')
            
            if [[ "$WORKSPACE_ID" == "null" || -z "$WORKSPACE_ID" ]]; then
              echo "âŒ Failed to create workspace"
              echo "$CREATE_RESPONSE"
              exit 1
            fi
            
            echo "âœ… Workspace created: $WORKSPACE_ID"
          fi
          
          echo "workspace_id=$WORKSPACE_ID" >> $GITHUB_OUTPUT

      - name: Set Workspace Variables
        run: |
          set -e
          
          WORKSPACE_ID="${{ steps.workspace.outputs.workspace_id }}"
          
          # Function to set variable
          set_variable() {
            local KEY=$1
            local VALUE=$2
            local SENSITIVE=$3
            local CATEGORY=${4:-terraform}
            
            # Check if variable exists
            VAR_CHECK=$(curl -s \
              --header "Authorization: Bearer $TF_API_TOKEN" \
              "https://app.terraform.io/api/v2/workspaces/$WORKSPACE_ID/vars" | \
              jq -r ".data[] | select(.attributes.key == \"$KEY\") | .id")
            
            if [[ -n "$VAR_CHECK" ]]; then
              # Update existing variable
              curl -s \
                --header "Authorization: Bearer $TF_API_TOKEN" \
                --header "Content-Type: application/vnd.api+json" \
                --request PATCH \
                --data '{
                  "data": {
                    "attributes": {
                      "value": "'"$VALUE"'",
                      "sensitive": '$SENSITIVE'
                    }
                  }
                }' \
                "https://app.terraform.io/api/v2/vars/$VAR_CHECK" > /dev/null
            else
              # Create new variable
              curl -s \
                --header "Authorization: Bearer $TF_API_TOKEN" \
                --header "Content-Type: application/vnd.api+json" \
                --request POST \
                --data '{
                  "data": {
                    "attributes": {
                      "key": "'"$KEY"'",
                      "value": "'"$VALUE"'",
                      "sensitive": '$SENSITIVE',
                      "category": "'"$CATEGORY"'"
                    },
                    "type": "vars"
                  }
                }' \
                "https://app.terraform.io/api/v2/workspaces/$WORKSPACE_ID/vars" > /dev/null
            fi
          }
          
          echo "ðŸ“ Setting workspace variables..."
          
          # Azure credentials (environment variables)
          set_variable "ARM_CLIENT_ID" "$ARM_CLIENT_ID" true "env"
          set_variable "ARM_CLIENT_SECRET" "$ARM_CLIENT_SECRET" true "env"
          set_variable "ARM_SUBSCRIPTION_ID" "$ARM_SUBSCRIPTION_ID" true "env"
          set_variable "ARM_TENANT_ID" "$ARM_TENANT_ID" true "env"
          
          # Terraform variables
          set_variable "environment" "${{ needs.detect-changes.outputs.environment }}" false "terraform"
          set_variable "ephemeral" "${{ needs.detect-changes.outputs.ephemeral }}" false "terraform"
          set_variable "run_id" "${{ needs.detect-changes.outputs.run_id }}" false "terraform"
          
          # Disable expensive features for ephemeral
          if [[ "${{ needs.detect-changes.outputs.ephemeral }}" == "true" ]]; then
            set_variable "enable_icinga" "false" false "terraform"
            set_variable "enable_function_app" "false" false "terraform"
          fi
          
          echo "âœ… Variables set"

      - name: Generate Terraform Variables
        working-directory: ${{ env.TF_VAR_FILE_PATH }}
        run: |
          ENV="${{ needs.detect-changes.outputs.environment }}"
          EPHEMERAL="${{ needs.detect-changes.outputs.ephemeral }}"
          RUN_ID="${{ needs.detect-changes.outputs.run_id }}"
          
          # Create cicd.auto.tfvars for CI/CD specific overrides
          cat > cicd.auto.tfvars <<EOF
          # Auto-generated by CI/CD pipeline
          # Environment: $ENV
          # Run ID: $RUN_ID
          # Ephemeral: $EPHEMERAL
          
          environment = "$ENV"
          ephemeral   = $EPHEMERAL
          run_id      = "$RUN_ID"
          
          # Disable costly features for ephemeral deployments
          enable_icinga       = false
          enable_function_app = false
          
          # Cost-optimized settings for ephemeral
          $(if [[ "$EPHEMERAL" == "true" ]]; then
            echo "aks_ephemeral_node_count = 1"
            echo "aks_ephemeral_vm_size    = \"Standard_B2s\""
          fi)
          EOF
          
          echo "ðŸ“„ Generated cicd.auto.tfvars:"
          cat cicd.auto.tfvars

      - name: Terraform Init
        working-directory: ${{ env.TF_VAR_FILE_PATH }}
        run: |
          terraform init -input=false
        env:
          TF_WORKSPACE: ${{ needs.detect-changes.outputs.workspace_name }}

      - name: Terraform Plan
        working-directory: ${{ env.TF_VAR_FILE_PATH }}
        run: |
          terraform plan \
            -var-file="environments/${{ needs.detect-changes.outputs.environment }}.tfvars" \
            -out=tfplan \
            -input=false
        env:
          TF_WORKSPACE: ${{ needs.detect-changes.outputs.workspace_name }}

      - name: Terraform Apply
        working-directory: ${{ env.TF_VAR_FILE_PATH }}
        run: |
          terraform apply -auto-approve tfplan
        env:
          TF_WORKSPACE: ${{ needs.detect-changes.outputs.workspace_name }}

      - name: Extract Terraform Outputs
        id: outputs
        working-directory: ${{ env.TF_VAR_FILE_PATH }}
        run: |
          echo "ðŸ“¤ Extracting Terraform outputs..."
          
          ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
          ACR_ADMIN_USER=$(terraform output -raw acr_admin_username 2>/dev/null || echo "")
          AKS_CLUSTER_NAME=$(terraform output -raw aks_cluster_name)
          RESOURCE_GROUP=$(terraform output -raw resource_group_name)
          
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "acr_admin_user=$ACR_ADMIN_USER" >> $GITHUB_OUTPUT
          echo "aks_cluster_name=$AKS_CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "resource_group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          
          echo "âœ… Infrastructure outputs:"
          echo "  ACR: $ACR_LOGIN_SERVER"
          echo "  AKS: $AKS_CLUSTER_NAME"
          echo "  RG: $RESOURCE_GROUP"
        env:
          TF_WORKSPACE: ${{ needs.detect-changes.outputs.workspace_name }}

  # ============================================================================
  # STAGE 4: BUILD AND PUSH DOCKER IMAGES
  # ============================================================================
  build:
    name: ðŸ³ Build ${{ matrix.service }}
    runs-on: ubuntu-latest
    needs: [detect-changes, terraform-provision]
    if: needs.terraform-provision.result == 'success'
    strategy:
      fail-fast: false
      matrix:
        service: [auth-service, search-service, frontend-service]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ needs.terraform-provision.outputs.acr_login_server }}
          username: ${{ needs.terraform-provision.outputs.acr_admin_user }}
          password: ${{ secrets.ACR_ADMIN_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./services/${{ matrix.service }}
          file: ./services/${{ matrix.service }}/Dockerfile
          push: true
          tags: |
            ${{ needs.terraform-provision.outputs.acr_login_server }}/qnt9-${{ matrix.service }}:${{ github.sha }}
            ${{ needs.terraform-provision.outputs.acr_login_server }}/qnt9-${{ matrix.service }}:${{ needs.detect-changes.outputs.environment }}-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            ENVIRONMENT=${{ needs.detect-changes.outputs.environment }}
            BUILD_NUMBER=${{ github.run_number }}

      - name: Scan image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ needs.terraform-provision.outputs.acr_login_server }}/qnt9-${{ matrix.service }}:${{ github.sha }}'
          format: 'sarif'
          output: 'trivy-results-${{ matrix.service }}.sarif'
          severity: 'CRITICAL,HIGH'
        continue-on-error: true

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results-${{ matrix.service }}.sarif'
        continue-on-error: true

  # ============================================================================
  # STAGE 5: UNIT TESTS
  # ============================================================================
  unit-tests:
    name: ðŸ§ª Unit Tests
    runs-on: ubuntu-latest
    needs: [detect-changes]
    if: needs.detect-changes.outputs.services_changed == 'true' || github.event.inputs.force_deploy == 'true'
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          pip install pytest pytest-cov pytest-asyncio httpx

      - name: Run Auth Service tests
        working-directory: services/auth-service
        run: |
          pip install -r requirements.txt
          pytest tests/ -v --cov=app --cov-report=xml --cov-report=term-missing
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test
          JWT_SECRET_KEY: test-secret-key
          REDIS_URL: redis://localhost:6379
        continue-on-error: true

      - name: Run Search Service tests
        working-directory: services/search-service
        run: |
          pip install -r requirements.txt
          pytest tests/ -v --cov=app --cov-report=xml --cov-report=term-missing
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test
          REDIS_URL: redis://localhost:6379
        continue-on-error: true

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./services/auth-service/coverage.xml,./services/search-service/coverage.xml
          flags: unittests
          fail_ci_if_error: false

  # ============================================================================
  # STAGE 6: DEPLOY TO KUBERNETES
  # ============================================================================
  deploy:
    name: ðŸš€ Deploy to ${{ needs.detect-changes.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [detect-changes, terraform-provision, build, unit-tests]
    if: |
      always() &&
      needs.terraform-provision.result == 'success' &&
      needs.build.result == 'success' &&
      (needs.unit-tests.result == 'success' || needs.unit-tests.result == 'skipped')
    environment:
      name: ${{ needs.detect-changes.outputs.environment }}
      url: https://${{ needs.terraform-provision.outputs.aks_cluster_name }}.${{ needs.detect-changes.outputs.environment }}.qnt9.io
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: |
            {
              "clientId": "${{ secrets.ARM_CLIENT_ID }}",
              "clientSecret": "${{ secrets.ARM_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.ARM_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.ARM_TENANT_ID }}"
            }

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.terraform-provision.outputs.resource_group }} \
            --name ${{ needs.terraform-provision.outputs.aks_cluster_name }} \
            --overwrite-existing

      - name: Create namespace
        run: |
          kubectl create namespace qnt9 --dry-run=client -o yaml | kubectl apply -f -

      - name: Create ACR secret
        run: |
          kubectl create secret docker-registry acr-secret \
            --docker-server=${{ needs.terraform-provision.outputs.acr_login_server }} \
            --docker-username=${{ needs.terraform-provision.outputs.acr_admin_user }} \
            --docker-password=${{ secrets.ACR_ADMIN_PASSWORD }} \
            --namespace=qnt9 \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create application secrets
        run: |
          kubectl create secret generic qnt9-secrets \
            --from-literal=database-url="${{ secrets.DATABASE_URL }}" \
            --from-literal=jwt-secret-key="${{ secrets.JWT_SECRET_KEY }}" \
            --from-literal=redis-url="${{ secrets.REDIS_URL }}" \
            --namespace=qnt9 \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy services
        run: |
          ENVIRONMENT="${{ needs.detect-changes.outputs.environment }}"
          ACR_LOGIN_SERVER="${{ needs.terraform-provision.outputs.acr_login_server }}"
          IMAGE_TAG="${{ github.sha }}"
          
          # Apply base configurations
          for manifest in infrastructure/kubernetes/base/*.yaml; do
            envsubst < "$manifest" | kubectl apply -f -
          done
          
          # Deploy each service
          for service in auth-service search-service frontend-service; do
            echo "Deploying $service..."
            
            for manifest in infrastructure/kubernetes/$service/*.yaml; do
              if [[ -f "$manifest" ]]; then
                export ENVIRONMENT ACR_LOGIN_SERVER IMAGE_TAG
                envsubst < "$manifest" | kubectl apply -f -
              fi
            done
          done

      - name: Wait for deployments
        run: |
          echo "â³ Waiting for deployments to be ready..."
          
          for service in auth-service search-service frontend-service; do
            kubectl rollout status deployment/$service -n qnt9 --timeout=300s || true
          done

      - name: Verify deployment health
        run: |
          echo "ðŸ¥ Checking deployment health..."
          
          kubectl get pods -n qnt9
          kubectl get services -n qnt9
          
          # Check pod status
          UNHEALTHY=$(kubectl get pods -n qnt9 -o jsonpath='{.items[?(@.status.phase!="Running")].metadata.name}')
          if [[ -n "$UNHEALTHY" ]]; then
            echo "âš ï¸ Unhealthy pods detected: $UNHEALTHY"
            kubectl describe pods -n qnt9 | grep -A 20 "Events:"
          fi

  # ============================================================================
  # STAGE 7: INTEGRATION TESTS
  # ============================================================================
  integration-tests:
    name: ðŸ”— Integration Tests
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy]
    if: needs.deploy.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install test dependencies
        run: |
          pip install -r tests/integration/requirements.txt

      - name: Run integration tests
        working-directory: tests/integration
        run: |
          pytest test_services_health.py -v --tb=short
        env:
          TEST_ENVIRONMENT: ${{ needs.detect-changes.outputs.environment }}
        continue-on-error: true

  # ============================================================================
  # STAGE 8: CLEANUP EPHEMERAL INFRASTRUCTURE
  # ============================================================================
  cleanup:
    name: ðŸ§¹ Cleanup Infrastructure
    runs-on: ubuntu-latest
    needs: [detect-changes, terraform-provision, integration-tests]
    if: |
      always() &&
      needs.detect-changes.outputs.ephemeral == 'true' &&
      github.event.inputs.skip_destroy != 'true' &&
      (needs.integration-tests.result == 'success' || needs.integration-tests.result == 'skipped' || needs.integration-tests.result == 'failure')
    
    env:
      TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Destroy Infrastructure
        working-directory: ${{ env.TF_VAR_FILE_PATH }}
        run: |
          WORKSPACE_NAME="${{ needs.detect-changes.outputs.workspace_name }}"
          
          echo "ðŸ—‘ï¸ Destroying infrastructure for workspace: $WORKSPACE_NAME"
          
          terraform init -input=false
          terraform destroy \
            -var-file="environments/${{ needs.detect-changes.outputs.environment }}.tfvars" \
            -var="ephemeral=true" \
            -var="run_id=${{ needs.detect-changes.outputs.run_id }}" \
            -auto-approve
        env:
          TF_WORKSPACE: ${{ needs.detect-changes.outputs.workspace_name }}
        continue-on-error: true

      - name: Delete HCP Terraform Workspace
        run: |
          WORKSPACE_NAME="${{ needs.detect-changes.outputs.workspace_name }}"
          
          echo "ðŸ—‘ï¸ Deleting workspace: $WORKSPACE_NAME"
          
          # Get workspace ID
          WORKSPACE_ID=$(curl -s \
            --header "Authorization: Bearer $TF_API_TOKEN" \
            "https://app.terraform.io/api/v2/organizations/$TF_CLOUD_ORGANIZATION/workspaces/$WORKSPACE_NAME" | \
            jq -r '.data.id')
          
          if [[ "$WORKSPACE_ID" != "null" && -n "$WORKSPACE_ID" ]]; then
            # Delete workspace
            curl -s \
              --header "Authorization: Bearer $TF_API_TOKEN" \
              --request DELETE \
              "https://app.terraform.io/api/v2/workspaces/$WORKSPACE_ID"
            
            echo "âœ… Workspace deleted"
          else
            echo "âš ï¸ Workspace not found or already deleted"
          fi
        continue-on-error: true

  # ============================================================================
  # PIPELINE SUMMARY
  # ============================================================================
  summary:
    name: ðŸ“Š Pipeline Summary
    runs-on: ubuntu-latest
    needs: [detect-changes, lint, terraform-provision, build, unit-tests, deploy, integration-tests, cleanup]
    if: always()
    
    steps:
      - name: Generate Summary
        run: |
          echo "# ðŸ“‹ QNT9-SRS Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## ðŸ”§ Configuration" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | \`${{ needs.detect-changes.outputs.environment }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Ephemeral | \`${{ needs.detect-changes.outputs.ephemeral }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Run ID | \`${{ needs.detect-changes.outputs.run_id }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Workspace | \`${{ needs.detect-changes.outputs.workspace_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## ðŸ“Š Stage Results" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ” Detect Changes | \`${{ needs.detect-changes.result }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ§¹ Lint | \`${{ needs.lint.result }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ—ï¸ Terraform | \`${{ needs.terraform-provision.result }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ³ Build | \`${{ needs.build.result }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ§ª Unit Tests | \`${{ needs.unit-tests.result }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸš€ Deploy | \`${{ needs.deploy.result }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ”— Integration Tests | \`${{ needs.integration-tests.result }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ§¹ Cleanup | \`${{ needs.cleanup.result }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.terraform-provision.result }}" == "success" ]]; then
            echo "## ðŸ­ Infrastructure" >> $GITHUB_STEP_SUMMARY
            echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| ACR | \`${{ needs.terraform-provision.outputs.acr_login_server }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| AKS | \`${{ needs.terraform-provision.outputs.aks_cluster_name }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| Resource Group | \`${{ needs.terraform-provision.outputs.resource_group }}\` |" >> $GITHUB_STEP_SUMMARY
          fi
